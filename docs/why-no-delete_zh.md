# 为什么 devclean 不删除文件（至少现在不）

在第一次了解 devclean 时，很多人会问一个很自然的问题：

> **“既然你已经知道哪些目录是构建产物，为什么不直接帮我删掉？”**

这是一个合理的问题。
但 devclean 选择 **不删除任何文件**，并不是因为“暂时没做”，而是一个**经过深思熟虑的设计决定**。

---

## 删除从来不是难点

对开发者来说，删除文件并不困难：

- `rm -rf`
- `cargo clean`
- `npm install`
- `gradle clean`

这些工具已经存在很多年，也被广泛使用。

真正困难的，从来不是“怎么删”，而是：

> **“我到底能不能确定，删了不会出问题？”**

---

## devclean 解决的是“不确定性”，而不是“删除能力”

devclean 的核心目标是回答一个问题：

> **这个目录是否是构建产物？为什么？风险有多大？**

这是一种**判断问题**，而不是执行问题。

一旦 devclean 开始删除文件，它就从一个：
- 提供判断依据的工具

变成了一个：
- 替用户承担后果的工具

这两者的责任边界完全不同。

---

## 删除会立刻改变信任模型

哪怕加上：
- 多次确认
- `--force`
- `--i-know-what-im-doing`

删除行为依然会改变用户的潜意识认知：

| 工具行为 | 用户心理 |
|--------|--------|
| 只分析 | “我在参考建议” |
| 自动删除 | “是工具替我做的决定” |

devclean 不希望成为“替你承担风险”的工具。

---

## Scan-only 是一种安全边界

devclean 的设计原则是：

> **分析与执行必须分离**

- devclean 负责：
  - 扫描
  - 解释
  - 给出置信度
- 用户负责：
  - 判断
  - 决策
  - 执行删除

这种边界让 devclean：
- 更可预测
- 更容易信任
- 更适合大型项目和陌生代码库

---

## Suggested commands：降低成本，但不越界

为了减少用户的操作成本，devclean 会在置信度足够高时提供：

> **明确、可复制执行的清理命令建议**

例如：

```text
Suggested command:
  cargo clean
````

这些命令：

* 永远不会被自动执行
* 完全由用户自行决定是否运行
* 通常是开发者已经熟悉的原生命令

这是一种**“接近删除体验，但不承担删除风险”**的折中设计。

---

## 不删除，是为了更长远的信任

devclean 宁愿：

* 少做一点
* 慢一点
* 保守一点

也不希望：

* 一次误删
* 就破坏整个工具的可信度

在文件系统层面，**一次错误的删除，代价往往是不可逆的**。

---

## 那未来会支持删除吗？

也许会，但前提非常严格。

如果 devclean 将来引入任何形式的删除能力，必须满足：

* 默认关闭
* 强制交互确认
* 可回滚（例如移动到私有回收区）
* 完整日志记录
* 与分析逻辑明确隔离

在这些条件满足之前，**scan-only 会一直是 devclean 的核心特性**。

---

## 总结

devclean 的目标不是帮你删掉多少文件，而是：

> **让你在删除之前，不再犹豫。**

这是一个关于判断、解释和信任的工具。

删除很简单，
做出正确的删除决定，才是困难的部分。
